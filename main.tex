\documentclass[runningheads]{llncs}
\usepackage{listings}
\lstset{
  inputencoding=utf8,
  extendedchars=true,
  basicstyle=\footnotesize\ttfamily,
  mathescape=true,
  escapeinside={(*}{*)},
}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amsfonts}

\newcommand{\snip}[1]{\footnotesize{\ttfamily{#1}}}

\begin{document}
\title{Elaboration on Overloaded Functions}
\author{Marius Weidner}
\institute{Chair of Programming Languages, University of Freiburg}
\maketitle

\begin{abstract}
Most popular programming languages support function overloading. Prominent use cases include overloading of arithmetic operators for different types or showing a arbitrary value as a string. We study a minimal extension of the Hindley Milner system that supports function overloading~\cite{system-o}. We also derive an alternative system with support for recursive instances, straight forward debruijn indices and give big step semantics.
\end{abstract}

\section{Introduction}
When we talk about shared or overloaded functions we usually mean overloaded identifiers. If we invoke overloaded identifiers as functions we expect the language to choose the correct implementation of multiple given implementations for us based on the type of the arguments.

\subsection{Example}
\begin{figure}
  \begin{lstlisting}
inst eq :: Nat -> Nat -> Bool
  eq zero    zero    = true
  eq (suc x) (suc y) = eq x y
  eq _       _       = false in
inst eq :: (eq :: a -> a -> Bool) => [a] -> [a] -> Bool
  eq nil         nil         = true
  eq (cons x xs) (cons y ys) = eq x y && eq xs ys
  eq _           _           = false in
let is_eq = eq [0] [0] in ()

  \end{lstlisting}
  \caption{Overloading Example in Preudocode} \label{example}
\end{figure}
\noindent In Fig.~\ref{example} we give a pseudo code example in a function language. Commonly known data types \snip{Nat}, \snip{Bool} and \snip{List} are assumed to be predefined. With syntax similar to \snip{let} statements, \snip{inst} statements provide a concrete implementation for an overloaded identifier with explicit type annotation. The type annotation is used to determine the correct implementation when the overloaded identifier is called. In contrast \snip{let} identifiers cannot be overloaded and all types are inferred. 

We begin with two implementations for \snip{eq}. From the explicit type annotation, we can deduce that the first implementation takes two \snip{Nat} and performs pattern matching to determine if the are equal. 
The second implementation is for lists of any type that has an implementation for \snip{eq}. More precisely, the constraint \snip{(eq \ :: \ a -> a -> Bool) => ..} expresses that we need to have an implementation at hand for the type that is substituted for the type variable \snip{a} when using the second implementation of \snip{eq}. Inside the second implementation we can safely call \snip{eq} on elements of the list and on sub lists, given the language supports recursive implementations. While \snip{eq [zero] [zero]} would type check, \snip{eq [true] [true]} would fail to type check, because the constraint for \snip{eq} of lists requires an implementation of \snip{eq} for \snip{Bool -> Bool -> Bool}.
\subsection{Examples of Overloading in Popular Languages}
\paragraph{Python} uses magic methods to support overloading of operators and standard library functions. A class can override the behavior of any of the predefined magic methods. Commonly used magic methods are for example \snip{\_\_init\_\_(self)} to provide logic when an object is initialized and \snip{\_\_eq\_\_(self, other)}to give custom equality logic for objects when using the \snip{==} operator. In Python it is not possible to define custom magic methods or any other form of custom overloading.
\paragraph{Haskell} makes use of type classes. Type classes usually have type variables and define abstract functions that can be overloaded. A type can be an instance of a type class by concretely defining the behavior for all functions required by the type class when the type variables of the type class have some explicit type. Type variables can be constrained to be an instance of one or more type classes. The type checker then searches for a suitable instance by instance resolution.
\paragraph{Rust} has a language feature called traits. Similar to Haskell's type classes, a trait defines shared functionality in the form of abstract function definitions. Traits are then implemented for one or more types, possibly using type variables themselves. Type variables can be annotated with a trait bound forcing a concrete type, when substituted for the type variable, to have implemented a specific trait. Similar to Python some traits are predefined to overload operators. In contrast to Haskell's type classes, traits can also act as a special kind of types using the \snip{dyn} and \snip{impl} keywords.
\section{System O}
System O is a minimal extension to the Hindley Milner system~\cite{hindley-milner} by Odersky, Wadler and Wehr~\cite{system-o} and supports overloaded identifiers for functions. To determine the correct instance for a call to an overloaded function System O restricts instances for the same identifier to differ in the type of their first argument. It is therefore straight forward to formulate untyped semantics, since we can determine the type of the first argument uniquely by the value given.
\subsection{Example}
\subsection{Type Inference Algorithm}
\subsection{Dictionary Passing Transformation to Hindley Milner}
\subsection{Record Extension}
\section{Extending System O}
We extend System O by recursive instances and give big step semantics. We also design the system to be used with debruijn indices.
\subsection{Syntax}
\begin{figure}
  \begin{align*}
    \text{Constructors} \quad k \ &\in \ \mathcal{K} = \bigcup\{\mathcal{K}_D \ | \ D \in \mathcal{D}\} \\
    \text{Unique Variables} \quad u \ &\in \ \mathcal{U}\\
    \text{Overloaded Variables} \quad o \ &\in \ \mathcal{O}\\
    \text{Variables} \quad x\ &:= u  \ | \ o  \ | \ k\\
    \text{Expressions} \quad e \ &:= \ x \ | \ \lambda x. \ e \ | \ e \ e \ | \ \textbf{let} \ x = e \ \textbf{in} \ e \\
    \text{Programs} \quad p \ &:= \ \textbf{decl} \ o \ \textbf{in} \ p \ | \ \textbf{inst} \ o :  \sigma_T  = e \ \textbf{in} \ p \\
    \\
    \text{Datatype constructors} \quad D \ &\in \ \mathcal{D} \\
    \text{Type constructors} \quad T \ &\in \ \mathcal{T} = \mathcal{D} \cup \{\rightarrow\} \\ 
    \text{Type variables} \quad \alpha \ &\in \ \mathcal{A} \\
    \text{Mono types} \quad \tau \ &:=  \ \alpha \ | \ \tau \rightarrow \tau \ | \ D \ \tau_1 \ .. \ \tau_n \\
    \text{Poly types} \quad \sigma \ &:=  \ \tau \ | \ \forall \alpha. \ \pi_\alpha \Rightarrow \sigma \\
    \text{Instance types} \quad \sigma_T \ &:= \ T \ \alpha_1 \ .. \ \alpha_n \rightarrow \tau \ | \ \forall \alpha. \ \pi_\alpha \Rightarrow \sigma_T \\  
    \text{Constraints} \quad \pi_\alpha \ &:= x_1 : \alpha \rightarrow \tau_1 \ .. \ x_n : \alpha \rightarrow \tau_n \\
    \\
    \text{Instance Type Contexts} \quad \Sigma \ &:= \ \cdot \ | \ \Sigma \uplus  \sigma_T \\
    \text{Type Contexts} \quad \Gamma \ &:= \ \cdot \ | \ \Gamma, \ x : \sigma \ | \ \Gamma, \ o : \Sigma \ | \ \Gamma(o) \uplus \sigma_T \\
    \\
    \text{Values} \quad v \ &:=  \lambda (\mathcal{E}; \ x). \ e \ | \ k \ v_1 \ .. \ v_n \ | \ \mathcal{S} \\
    \text{Instance Eval Contexts} \quad \mathcal{S} \ &:= \ \cdot \ | \ \mathcal{S} \uplus  (e ,\ T) \\
    \text{Evaluation Contexts} \quad \mathcal{E} \ &:= \ \cdot \ | \ \mathcal{E}, \ x : v  \ | \ \mathcal{E}(o) \uplus (e, \ T)
  \end{align*}
  \caption{Syntax}
\end{figure}
\noindent We only discuss changes to the original System O syntax.

The $\textbf{decl}$ statement declares an identifier $o$ to be overloaded in $p$. Identifiers can only have instances, if declared as overloaded.

Typing context $\Gamma$ can hold one or more types per identifier. 
Normal identifiers $x$ have exactly one type $\sigma$ while overloaded identifiers have a list of types $\Sigma$ with length equal to the amount of instance definitions. 
We write $\Gamma(o) \uplus \sigma_T$ to append a type $\sigma_T$ to the list of types $\Sigma$ of identifier $o$.

A value $v$ can be a closure $\lambda (\mathcal{E}; \ x). \ e$, constructor $k$ applied to values $v_1$ to $v_n$ or a list $\mathcal{S}$ of type annotated expressions $(e, T)$. The latter occurs when an overloaded identifier is treated as value. 

The evaluation context $\mathcal{E}$ is analogous to the typing context $\Gamma$. 
$\mathcal{E}$ can hold exactly one value for normal identifiers $x$ and multiple typed expressions for overloaded identifiers $o$. 
We write $\mathcal{E}(o) \uplus (e, T)$ to append a type $(e, T)$ to the list of typed expressions $\mathcal{E}$ of identifier $o$.
\subsection{Typing}
\begin{figure}$$
  \begin{array}{c c c c} 
    \text{(T-Var)}
    &
    \displaystyle
    \frac{x: \sigma  \in \Gamma}
         {\Gamma \vdash x: \sigma }
    &
    \displaystyle
    \frac{o: \Sigma  \in \Gamma \quad \quad \sigma_T \in \Sigma}
    {\Gamma \vdash o: \sigma_T }
    &
    \text{(T-OVar)}
    \\\\
    \text{(T-Abs)}
    &
    \displaystyle
    \frac{\Gamma,\ x:\tau \vdash e : \tau^\prime}
         {\Gamma \vdash \lambda x. \ e : \tau \rightarrow \tau^\prime}
    &
    
    \displaystyle
    \frac{\Gamma \vdash e : \tau \rightarrow \tau^\prime \quad\quad \Gamma \vdash e^\prime : \tau}
         {\Gamma \vdash e \ e^\prime : \tau^\prime}
    &
    \text{(T-App)}
    \\\\
    \text{(T-Gen)}
    &
    \displaystyle
    \frac{\Gamma, \ \pi_\alpha\vdash e:\sigma \quad \quad \text{fresh }\alpha}
         {\Gamma \vdash e : \forall \alpha. \pi_\alpha \Rightarrow \ \sigma}
    &
    \displaystyle
    \frac{\Gamma \vdash e: \forall \alpha. \ \pi_\alpha \Rightarrow \sigma \quad \quad \Gamma \vdash [\tau/\alpha]\pi_\alpha}
         {\Gamma \vdash e:[\tau/\alpha]\sigma}
    &
    \text{(T-Inst)}
    \\\\
    \text{(T-Set)}
    &
    \displaystyle
    \frac{\Gamma \vdash x_1:\sigma_1  \quad ...\quad \Gamma \vdash x_n:\sigma_n}
         {\Gamma \vdash x_1:\sigma_1 \quad ...\quad x_n:\sigma_n}
    &
    \displaystyle
    \frac{\Gamma \vdash e^\prime : \sigma \quad \quad \Gamma,\ x:\sigma \vdash e : \tau}
         {\Gamma \vdash \textbf{let} \ x = e^\prime \ \textbf{in} \ e : \tau}
    &
    \text{(T-Let)}
    \\\\
    \text{(T-Decl)}
    &
    \displaystyle
    \frac{\Gamma, \ o: \cdot  \vdash p : \sigma}
         {\Gamma \vdash \textbf{decl} \ o \ \textbf{in} \ p : \sigma}
    &
    \displaystyle
    \frac{ \begin{matrix}
        \Gamma \vdash o : \Sigma \quad \quad  \forall \sigma_{T^\prime} \in \Sigma \Rightarrow T \neq T^\prime \\
        \Gamma(o) \uplus \sigma_T, \ \pi(\sigma_T) \vdash e : \sigma_T \quad \quad  \Gamma(o) \uplus \sigma_T \vdash p: \sigma
    \end{matrix}}
    {\Gamma \vdash \textbf{inst} \ o :  \sigma_T  = e \ \textbf{in} \ p : \sigma} 
    &
    \text{(T-Inst)}
  \end{array}$$
  \\\\
  where $\pi(\forall \alpha_1. \pi_1 .\ \ .. \ \forall \alpha_n. \pi_n. \ \tau) = \pi_1, \ .. , \ \pi_n$
  \caption{Typing ($\Gamma \vdash p : \sigma$)}
\end{figure}
\noindent Again, we only discuss changes to the original type system. 

Rule (T-OVar) says that an overloaded identifier $o$ has type $\sigma_T$ if it occurs in the list of function types $\Sigma$ that the variable is overloaded with. 

Rule (T-Decl) introduces an new overloaded variable $o$ to $p$ by appending $\Gamma$ in $p$ with the empty list, for future \textbf{inst}'s to append their explicit type.

Finally, (T-Inst) checks that for every $\sigma_T^\prime$ in $\Sigma$ of $o$ the constructor of the first argument is unique. To support recursive instances we append the type annotation of the instance $\sigma_T$ to $\Gamma$ when checking the body $e$. We also can to assume that all constraints $\pi(\sigma_T)$ are met inside $e$. 
\subsection{Big Step Semantics}
\begin{figure}$$
  \begin{array}{c c c c} 
    \text{(R-Var)}
    &
    \displaystyle
    \frac{x: v  \in \mathcal{E}}
         {\mathcal{E} \vdash x \downarrow v}
    &
    \displaystyle
    \frac{}
    {\mathcal{E} \vdash \lambda x. \ e \downarrow \lambda (\mathcal{E}; \ x). \ e}
    &
    \text{(R-Abs)}
    \\\\
    \text{(R-App)}
    &
    \displaystyle
    \frac{ \begin{matrix}
      \mathcal{E} \vdash e_1 \downarrow \lambda (\mathcal{E^\prime}; \ x). \ e \\
      \mathcal{E} \vdash e_2 \downarrow v_2 \quad \quad \mathcal{E}^\prime, \ x : v_2 \vdash e \downarrow v
    \end{matrix}}
         {\mathcal{E} \vdash e_1 \ e_2 \downarrow v}
    &
    \displaystyle
    \frac{ \begin{matrix}
      \mathcal{E} \vdash e_1 \downarrow S \quad \quad \mathcal{E} \vdash e_2 \downarrow v_2 \quad\quad \exists(e^\prime, \ T) \in S  \Rightarrow v_2 \sqsubseteq T \\
      \mathcal{E} \vdash e^\prime \downarrow \lambda (\mathcal{E^\prime}; \ x). \ e  \quad \quad \mathcal{E}^\prime, \ x : v_2 \vdash e \downarrow v
    \end{matrix}}
         {\mathcal{E} \vdash e_1 \ e_2 \downarrow v}
    &
    \text{(R-IApp)}
    \\\\
    \text{(R-Decl)}
    &
    \displaystyle
    \frac{\mathcal{E}, \ o : \cdot \vdash p \downarrow v}
         {\mathcal{E} \vdash \textbf{decl} \ o \ \textbf{in} \ p \downarrow v}
    &
    \displaystyle
    \frac{\mathcal{E}(o) \uplus (e, \ T) \vdash p \downarrow v}
         {\mathcal{E} \vdash \textbf{inst} \ o : \sigma_T = \ e \ \textbf{in} \ p \downarrow v}
    &
    \text{(R-Inst)}
    \\\\
    \text{(R-CApp)}
    &
    \displaystyle
    \frac{\mathcal{E} \vdash e_1 \downarrow v_1 \ .. \ \mathcal{E} \vdash e_1 \downarrow v_1}
         {\mathcal{E} \vdash k \ e_1 \ .. \ e_n \downarrow k \ v_1 \ .. \ v_n}
    &
    \displaystyle
    \frac{\mathcal{E} \vdash e^\prime \downarrow v^\prime \quad\quad \mathcal{E},\ x : v^\prime \vdash e \downarrow v}
         {\mathcal{E} \vdash \textbf{let} \ x = e^\prime \ \textbf{in} \ e \downarrow v}
    &
    \text{(R-Let)}
  \end{array}$$
  \\\\
  where $v \sqsubseteq T:$
  $$\begin{array}{c c c c c c} 
    \text{(C-Abs)}
    &
    \displaystyle
    \frac{}
         {\lambda (\mathcal{E}; \ x). \ e \sqsubseteq \ \rightarrow}
    &
    \text{(C-Cstr)}
    &
    \displaystyle
    \frac{k \in \mathcal{K}_D}
    {k \ v_1 \ .. \ v_n \sqsubseteq D}
    &
    \text{(C-Inst)}
    &
    \displaystyle
    \frac{}
    {S \sqsubseteq \ \rightarrow}
  \end{array}$$
  \caption{Big Step Semantics ($\mathcal{E} \vdash p \downarrow v$)}
\end{figure}
\noindent Rules (R-Var), (R-App), (R-Abs), (R-Let) are standard. 

(R-CApp) evaluates $n$-ary predefined constructors.

Analogous to (T-Decl), (R-Decl) 

When an overloaded identifier is invoked rule (T-IApp) is used. 

The binary relation $v \sqsubseteq T$ relates constructor values to their corresponding type. 
\subsection{Debruijn Indices}
\section{Conclusion}

\begin{thebibliography}{8}

\bibitem{system-o}Odersky, M., Wadler, P. \& Wehr, M. A Second Look at Overloading. {\em Proceedings Of The Seventh International Conference On Functional Programming Languages And Computer Architecture}. pp. 135-146 (1995), https://doi.org/10.1145/224164.224195
\bibitem{hindley-milner}Milner, R. A theory of type polymorphism in programming. {\em Journal Of Computer And System Sciences}. \textbf{17}, 348-375 (1978), https://www.sciencedirect.com/science/article/pii/0022000078900144
\end{thebibliography}
\end{document}
