\documentclass[runningheads]{llncs}
\usepackage{listings}
\lstset{
  inputencoding=utf8,
  extendedchars=true,
  basicstyle=\footnotesize\ttfamily,
  mathescape=true,
  escapeinside={(*}{*)},
}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{stmaryrd}
\usepackage{amsfonts}
\usepackage{hyperref}

\newcommand{\snip}[1]{\footnotesize{\ttfamily{#1}}}

\begin{document}
\title{Elaboration on Overloaded Functions}
\author{Marius Weidner}
\institute{Chair of Programming Languages, University of Freiburg}
\maketitle

\begin{abstract}
Real world programming languages need function overloading. Prominent use cases include overloading of arithmetic operators for different types or showing a arbitrary value as a string. We study a minimal extension of the Hindley Milner system~\cite{hm78} that supports function overloading~\cite{oww95}, while preserving full type inference. We also derive an alternative system with support for recursive instances, straight forward debruijn indices and give big step semantics.
\end{abstract}

\section{Introduction}
When we say "overloaded functions" we usually mean overloaded identifiers. An overloaded identifier has one or more \emph{instances}. Each instance works for a \emph{different} type for it's first argument and gives specific logic for when called on that type. If we invoke the overloaded identifiers as function we expect the type checker to choose the correct instance for us based on the type of the first argument. In combination with polymorphism we can go one step further by allowing quantified type variables to be restricted. A type variable can be restricted to be only substitutable by a type for which some instance, with that type as first argument, exists. Most of popular real world programming languages support overloading in a variety of ways, but they can usually be reduced to a more minimal system with only overloaded function identifiers. 

\subsection{Examples of Overloading in Popular Languages}
\paragraph{Python} uses magic methods to support overloading of operators and standard library functions. A class can override the behavior of any of the predefined magic methods. Commonly used magic methods are for example \snip{\_\_init\_\_(self)} to provide logic when an object is initialized and \snip{\_\_eq\_\_(self, other)} to give custom equality logic for objects when using the \snip{==} operator. In Python it is not possible to define custom magic methods or any other form of custom overloading.
\paragraph{Haskell} makes use of type classes. Type classes define abstract polymorphic functions that can be overloaded for specific types. Therefore we can instantiate a type class for specific types by concretely defining the behavior for all functions required by the type class when the type variables are substituted for those specific types. A function can have type class constraints to force substituted types for type variables to be a member of some instances. 
\paragraph{Rust} has a language feature called traits. Similar to Haskell's type classes, a trait defines shared functionality in the form of abstract function definitions. Traits are then implemented for one or more types. Type variables can be annotated with a trait bound forcing a concrete type, when substituted for the type variable, to have implemented a specific trait. Similar to Python some traits are predefined to overload operators, but custom traits can be defined. In contrast to Haskell's type classes, traits can also act as a special kind of types using the \snip{dyn} and \snip{impl} keywords.
\subsection{Example}
\begin{figure}
  \begin{lstlisting}
inst eq :: Nat -> Nat -> Bool
  eq zero    zero    = true
  eq (suc x) (suc y) = eq x y
  eq _       _       = false in
inst eq :: (eq :: a -> a -> Bool) => [a] -> [a] -> Bool
  eq nil         nil         = true
  eq (cons x xs) (cons y ys) = eq x y && eq xs ys
  eq _           _           = false in
let is_eq = eq [0] [0] in unit
  \end{lstlisting}
  \caption{Overloading Example in Preudocode} \label{example}
\end{figure}
\noindent 
In Fig.~\ref{example} we begin by defining two instances for \snip{eq}.  From the \emph{explicit type annotation}, we can follow that the first instance takes two \snip{Nat} and performs pattern matching to determine if the are equal. 
The second instance is for lists of any type that has an instance for \snip{eq}. More precisely, the constraint \snip{(eq \ :: \ a -> a -> Bool) => ..} expresses that we need to have an instance at hand for the type that is substituted for the type variable \snip{a} when using the second instance of \snip{eq}. Inside the second instance we can safely call \snip{eq} on elements of the list and on sub lists, given the language supports recursive instances. While \snip{eq [zero] [zero]} would type check, \snip{eq [true] [true]} would fail to type check, because the constraint for \snip{eq} of lists requires an instance of \snip{eq} for \snip{Bool -> Bool -> Bool}.
\section{System O}
System O is a minimal extension to the Hindley Milner system~\cite{hm78} by Odersky, Wadler and Wehr~\cite{oww95} and supports overloaded identifiers for functions.
\subsection{Syntax}
Hindley Milner's system~\cite{hm78} is extended by instance declarations and constraints on type variables.

Instance declarations $\textbf{inst} \ o : \sigma_T = e \ \textbf{in} \ p$ declare a new instance for overloaded identifier $o$ inside the rest of the program $p$. The explicit type annotation $\sigma_T$ can be a polymorphic \emph{function} type and index $T$ stores the type of the first argument. Body $e$ must be compatible with $\sigma_T$.

Polymorphic types $\sigma_T$ can introduce type variables $\alpha$ using the $\forall$ quantifier. On top of the original Hindley Milner quantifier $\forall \alpha. \ \sigma$, System O allows to introduce constraints $\pi_\alpha$ on $\alpha$ as a list of $o : \alpha \rightarrow \tau$ where $o$ is some overloaded identifier and $\tau$ is a monomorphic type. We write   $\forall \alpha. \ \pi_\alpha \Rightarrow \sigma = \forall \alpha. \ (o_i : \alpha \rightarrow \tau_i) \Rightarrow \sigma$. Constraints tell the type system that $\alpha$ can only be substituted by a type $\tau^\prime$ when there exists an instance $o : \tau^\prime \rightarrow \tau$.
\subsection{Type System}
System O's type system a simple an extension of Hindley Milner's typing rules~\cite{dm82}. 

The original (GEN) rule is renamed to ($\forall$-I) and extended by passing introduced constraints $\pi_\alpha$ from type scheme to context $\Gamma$. Therefore constraints $\pi_\alpha$ are presumed to be valid inside the expression $e$ that the $\forall$ was introduced to. To eliminate the presumed constraints inside the ($\forall$-E) rule (originally named (INST)), we not only eliminate the $\forall$ by substituting a concrete type for the bound type variable, but also substitute inside the constraints $\pi_\alpha$ and check if they follow form the environment $\Gamma$. 

Since $\pi_\alpha$ has the form of $o_i : \alpha \rightarrow \tau_i$, $i \in \mathbb{N}$ an additional rule (T-Set) is necessary which says that constraints $\pi_\alpha$ are valid if each constraint $o: \alpha \rightarrow \tau$ is valid.

Finally, there is an additional rule (INST) to type instance declarations. Since \snip{inst} declaration are similar to \snip{let} statements their typing is also similar. Other than with \snip{let}, we have an explicit type annotation $\sigma_T$ at hand where $T$ is the type of the first argument. We require all instances with the same name $o$ defined before in $\Gamma$ with type annotations $\sigma_{T^\prime}$ to differ in the type of the first argument $T^\prime$. This requirement is necessary to \emph{deterministically} find the correct instance when an overloaded identifier is invoked.
\subsection{Semantics}
To determine the correct instance for a call to an overloaded function at runtime, System O restricts instances for the same identifier to differ in the type of their first argument. It is therefore straight forward to formulate \emph{untyped} semantics, since we can determine the type of the first argument uniquely by the value given. The authors give denotational semantics and therefore define a meaning function $\llbracket \cdot \rrbracket_\eta$ that gives a term or type $\cdot$ a mathematical meaning in environment $\eta$. Inside section \ref{semantics} we give operational semantics for a slightly modified System O. 
\subsection{Type Inference Algorithm}
The authors extended Hindler Milner's Algorithm W~\cite{hm78}. We only discuss changes to the original Algorithm W.

The algorithm is extended by a case for \snip{inst} declarations. The \emph{infered} type $\sigma_T^\prime$ of the body $e$ must be \emph{less} general than the type annotation $\sigma_T$, e.g. $\mathbb{N} \rightarrow \mathbb{N}$ is less general than $\forall \alpha. \ \pi_\alpha \Rightarrow \alpha \rightarrow \alpha$.

The algorithm uses unification to produce a most general substitution $S^\prime$ in environment $\Gamma$ for two types $(\tau_1, \tau_2)$ and already given substitution $S$ in $\Gamma$. When binding a variable $\alpha$ to $\tau$ while unifying, all constraints $\pi_\alpha$ on $\alpha$ in $\Gamma$ are required to be true when substituting $\tau$ in $\pi_\alpha$ for $\alpha$.
\subsection{Dictionary Passing Transformation to Hindley Milner}
\begin{figure}
  \begin{lstlisting}
inst eq : Nat -> Nat -> Bool 
  = $\lambda$.. in                 
inst eq : $\forall$$\alpha$. (eq : $\alpha$ -> $\alpha$ -> Bool) => [$\alpha$] -> [$\alpha$] -> Bool 
  = $\lambda$.. in
eq [0] [0]
--------------------- translates to ---------------------
let eq$_0$ :: Nat -> Nat -> Bool
  = $\lambda$.. in
let eq$_1$ :: $\forall$$\alpha$. ($\alpha$ -> $\alpha$ -> Bool) -> [$\alpha$] -> [$\alpha$] -> Bool     
  = $\lambda$eq$_0$. $\lambda$.. in
eq$_1$ eq$_0$ [0] [0]  
  \end{lstlisting}
  \caption{Dictionary Passing Transform} \label{transform}
\end{figure}
The dictionary passing transform translates \emph{typed} System O programs to typeable Hindley Milner programs. The transformation uses type information to translate \snip{inst} declarations to \snip{let} bindings and constraints $\pi_\alpha$ to higher order functions. 

When substituting \snip{inst} declaration with \snip{let} bindings we omit the type annotation and introduce a new unique name for that instance. We  use type information to replace later invocations on that specific instance with the new unique name. 

Constraints $\pi_\alpha$ can only appear in the explicit type of instances. Constraints are transformed to \emph{arguments} of the translated instance. For each constraint $o : \alpha \rightarrow \tau$ we add a new argument to the let of type $\alpha \rightarrow \tau$. When invoking the unique name of the translated instance we pass the correct instances originally required by the constraints as arguments. Using the type information this is straight forward. While translating constraints to higher order functions it can happen that a type scheme is part of an function type. Since constraints $\pi_\alpha$ only use mono types $\tau$ and type variable $\alpha$ it is safe to define that $\tau \rightarrow \forall \alpha. \ \sigma \equiv \forall \alpha. \ \tau \rightarrow \sigma$ inside that process. Given this equivalence the translation results in typeable Hindley Milner programs.

An example translation can be found in Fig.~\ref{transform}.

\subsection{Relationship with Record Typing}
\begin{figure}
  \begin{lstlisting}
let max :: $\forall$$\beta$. (gte : $\beta$ -> $\beta$ -> Bool) 
            => $\forall$$\alpha$. ($\alpha$ $\leq$ {key: $\beta$}) => $\alpha$ -> $\alpha$ -> $\alpha$      
  = $\lambda$x. $\lambda$y. if gte x.key y.key then x else y in
max {field: "a", key: 1} {field: "b", key: 2}
------------------ translates to ------------------
inst field : $\forall$$\alpha$. $\forall$$\beta$. R$_0$ $\alpha$ $\beta$ -> $\alpha$ = $\lambda$R$_0$ x y. x in
inst key : $\forall$$\alpha$. $\forall$$\beta$. R$_0$ $\alpha$ $\beta$ -> $\beta$ = $\lambda$R$_0$ x y. y in
let max :: $\forall$$\beta$. (gte : $\beta$ -> $\beta$ -> Bool) 
            => $\forall$$\alpha$. (key : $\alpha$ -> $\beta$) => $\alpha$ -> $\alpha$ -> $\alpha$
  = $\lambda$x. $\lambda$y. if gte (key x) (key y) then x else y in
max (R$_0$ "a" 1) (R$_0$ "b" 2)  
  \end{lstlisting}
  \caption{Translating Records + Subtyping to System O} \label{translate}
\end{figure}
System O can be extended with records and subtyping on records. More surprisingly this extended language can be translated \emph{back} to System O without the record extension.

The record extension introduces record types $\{l_i : \tau_i\}_{i \in \mathbb{N}}$, record expressions $\{l_i = e_i \}_{i \in \mathbb{N}}$, selectors $e.l$ selecting label $l$ on record $e$ and subtyping constraints $a \leq b$ where $a$ must have all fields of $b$ with the same type, but can have even more fields with arbitrary types that $b$ does not have.

% todo

A minimal example can be found in Fig.~\ref{translate}
\section{Extending System O}
We extend System O by recursive instances and give big step semantics. The system is designed to straight forwardly use debruijn representation. First we extend syntax and type system, then we give big steps semantics and finally study the use of debruijn indices. 
\subsection{Syntax}
\begin{figure}
  \begin{align*}
    \text{Constructors} \quad k \ &\in \ \mathcal{K} = \bigcup\{\mathcal{K}_D \ | \ D \in \mathcal{D}\} \\
    \text{Unique Variables} \quad u \ &\in \ \mathcal{U}\\
    \text{Overloaded Variables} \quad o \ &\in \ \mathcal{O}\\
    \text{Variables} \quad x\ &:= u  \ | \ o  \ | \ k\\
    \text{Expressions} \quad e \ &:= \ x \ | \ \lambda x. \ e \ | \ e \ e \ | \ \textbf{let} \ x = e \ \textbf{in} \ e \\
    \text{Programs} \quad p \ &:= \ \textbf{decl} \ o \ \textbf{in} \ p \ | \ \textbf{inst} \ o :  \sigma_T  = e \ \textbf{in} \ p \\
    \\
    \text{Datatype constructors} \quad D \ &\in \ \mathcal{D} \\
    \text{Type constructors} \quad T \ &\in \ \mathcal{T} = \mathcal{D} \cup \{\rightarrow\} \\ 
    \text{Type variables} \quad \alpha \ &\in \ \mathcal{A} \\
    \text{Mono types} \quad \tau \ &:=  \ \alpha \ | \ \tau \rightarrow \tau \ | \ D \ \tau_1 \ .. \ \tau_n \\
    \text{Poly types} \quad \sigma \ &:=  \ \tau \ | \ \forall \alpha. \ \pi_\alpha \Rightarrow \sigma \\
    \text{Instance types} \quad \sigma_T \ &:= \ T \ \alpha_1 \ .. \ \alpha_n \rightarrow \tau \ | \ \forall \alpha. \ \pi_\alpha \Rightarrow \sigma_T \\  
    \text{Constraints} \quad \pi_\alpha \ &:= x_1 : \alpha \rightarrow \tau_1 \ .. \ x_n : \alpha \rightarrow \tau_n \\
    \\
    \text{Instance Type Contexts} \quad \Sigma \ &:= \ \cdot \ | \ \Sigma \uplus  \sigma_T \\
    \text{Type Contexts} \quad \Gamma \ &:= \ \cdot \ | \ \Gamma, \ x : \sigma \ | \ \Gamma, \ o : \Sigma \ | \ \Gamma(o) \uplus \sigma_T \\
    \\
    \text{Values} \quad v \ &:=  \lambda (\mathcal{E}; \ x). \ e \ | \ k \ v_1 \ .. \ v_n \ | \ \mathcal{S} \\
    \text{Instance Eval Contexts} \quad \mathcal{S} \ &:= \ \cdot \ | \ \mathcal{S} \uplus  (e ,\ T) \\
    \text{Evaluation Contexts} \quad \mathcal{E} \ &:= \ \cdot \ | \ \mathcal{E}, \ x : v  \ | \ \mathcal{E}(o) \uplus (e, \ \sigma_T)
  \end{align*}
  \caption{Syntax}
\end{figure}
\noindent We only discuss changes to the original System O syntax.

The $\textbf{decl}$ statement declares an identifier $o$ to be overloaded in $p$. Identifiers can only have instances, if declared as overloaded.

Typing context $\Gamma$ can hold one or more types per identifier. 
Normal identifiers $x$ have exactly one type $\sigma$ while overloaded identifiers have a list of types $\Sigma$ with length equal to the amount of instance definitions. 
We write $\Gamma(o) \uplus \sigma_T$ to append a type $\sigma_T$ to the list of types $\Sigma$ of identifier $o$.

A value $v$ can be a closure $\lambda (\mathcal{E}; \ x). \ e$, constructor $k$ applied to values $v_1$ to $v_n$ or a list $\mathcal{S}$ of type annotated expressions $(e, T)$. The latter occurs when an overloaded identifier is treated as value. 

The evaluation context $\mathcal{E}$ is analogous to the typing context $\Gamma$. 
$\mathcal{E}$ can hold exactly one value for normal identifiers $x$ and multiple typed expressions for overloaded identifiers $o$. 
We write $\mathcal{E}(o) \uplus (e, \sigma_T)$ to append a type $(e, \sigma_T)$ to the list of typed expressions $\mathcal{E}$ of identifier $o$.
\subsection{Typing}
\begin{figure}$$
  \begin{array}{c c c c} 
    \text{(T-Var)}
    &
    \displaystyle
    \frac{x: \sigma  \in \Gamma}
         {\Gamma \vdash x: \sigma }
    &
    \displaystyle
    \frac{o: \Sigma  \in \Gamma \quad \quad \sigma_T \in \Sigma}
    {\Gamma \vdash o: \sigma_T }
    &
    \text{(T-OVar)}
    \\\\
    \text{(T-Abs)}
    &
    \displaystyle
    \frac{\Gamma,\ x:\tau \vdash e : \tau^\prime}
         {\Gamma \vdash \lambda x. \ e : \tau \rightarrow \tau^\prime}
    &
    
    \displaystyle
    \frac{\Gamma \vdash e : \tau \rightarrow \tau^\prime \quad\quad \Gamma \vdash e^\prime : \tau}
         {\Gamma \vdash e \ e^\prime : \tau^\prime}
    &
    \text{(T-App)}
    \\\\
    \text{(T-Gen)}
    &
    \displaystyle
    \frac{\Gamma, \ \pi_\alpha\vdash e:\sigma \quad \quad \text{fresh }\alpha}
         {\Gamma \vdash e : \forall \alpha. \pi_\alpha \Rightarrow \ \sigma}
    &
    \displaystyle
    \frac{\Gamma \vdash e: \forall \alpha. \ \pi_\alpha \Rightarrow \sigma \quad \quad \Gamma \vdash [\tau/\alpha]\pi_\alpha}
         {\Gamma \vdash e:[\tau/\alpha]\sigma}
    &
    \text{(T-Inst)}
    \\\\
    \text{(T-Set)}
    &
    \displaystyle
    \frac{\Gamma \vdash x_1:\sigma_1  \quad ...\quad \Gamma \vdash x_n:\sigma_n}
         {\Gamma \vdash x_1:\sigma_1 \quad ...\quad x_n:\sigma_n}
    &
    \displaystyle
    \frac{\Gamma \vdash e^\prime : \sigma \quad \quad \Gamma,\ x:\sigma \vdash e : \tau}
         {\Gamma \vdash \textbf{let} \ x = e^\prime \ \textbf{in} \ e : \tau}
    &
    \text{(T-Let)}
    \\\\
    \text{(T-Decl)}
    &
    \displaystyle
    \frac{\Gamma, \ o: \cdot  \vdash p : \sigma \quad\quad \text{fresh} \ o}
         {\Gamma \vdash \textbf{decl} \ o \ \textbf{in} \ p : \sigma}
    &
    \displaystyle
    \frac{ \begin{matrix}
        \Gamma \vdash o : \Sigma \quad \quad  \forall \sigma_{T^\prime} \in \Sigma \Rightarrow T \neq T^\prime \\
        \Gamma(o) \uplus \sigma_T %, \ \pi(\sigma_T)
        \vdash e : \sigma_T \quad \quad  \Gamma(o) \uplus \sigma_T \vdash p: \sigma
    \end{matrix}}
    {\Gamma \vdash \textbf{inst} \ o :  \sigma_T  = e \ \textbf{in} \ p : \sigma} 
    &
    \text{(T-Inst)}
  \end{array}$$
  % \\\\ where $\pi(\forall \alpha_1. \pi_1 .\ \ .. \ \forall \alpha_n. \pi_n. \ \tau) = \pi_1, \ .. , \ \pi_n$
  \caption{Typing ($\Gamma \vdash p : \sigma$)}
\end{figure}
\noindent Again, we only discuss changes to the original type system. 

Rule (T-OVar) says that an overloaded identifier $o$ has type $\sigma_T$ if it occurs in the list of function types $\Sigma$ that the variable is overloaded with. 

Rule (T-Decl) introduces an new overloaded variable $o$ to $p$ by appending $\Gamma$ in $p$ with the empty list, for future \textbf{inst}'s to append their explicit type.

Finally, (T-Inst) checks that for every $\sigma_T^\prime$ in $\Sigma$ of $o$ the constructor of the first argument $T$ is unique. To support recursive instances we append the type annotation of the instance $\sigma_T$ to $\Gamma$ when checking the body $e$. % We also can to assume that all constraints $\pi(\sigma_T)$ are met inside $e$. 
\subsection{Big Step Semantics}
\label{semantics}
\begin{figure}$$
  \begin{array}{c c c c} 
    \text{(R-Var)}
    &
    \displaystyle
    \frac{x: v  \in \mathcal{E}}
         {\mathcal{E} \vdash x \downarrow v}
    &
    \displaystyle
    \frac{}
    {\mathcal{E} \vdash \lambda x. \ e \downarrow \lambda (\mathcal{E}; \ x). \ e}
    &
    \text{(R-Abs)}
    \\\\
    \text{(R-App)}
    &
    \displaystyle
    \frac{ \begin{matrix}
      \mathcal{E} \vdash e_1 \downarrow \lambda (\mathcal{E^\prime}; \ x). \ e \\
      \mathcal{E} \vdash e_2 \downarrow v_2 \quad \quad \mathcal{E}^\prime, \ x : v_2 \vdash e \downarrow v
    \end{matrix}}
         {\mathcal{E} \vdash e_1 \ e_2 \downarrow v}
    &
    \displaystyle
    \frac{ \begin{matrix}
      \mathcal{E} \vdash e_1 \downarrow S \quad \quad \mathcal{E} \vdash e_2 \downarrow v_2  \\
      \exists(e^\prime, \ \sigma_T) \in S  \Rightarrow v_2 \sqsubseteq T \\
      \mathcal{E} \vdash e^\prime \downarrow \lambda (\mathcal{E^\prime}; \ x). \ e  \quad \quad \mathcal{E}^\prime, \ x : v_2 \vdash e \downarrow v
    \end{matrix}}
         {\mathcal{E} \vdash e_1 \ e_2 \downarrow v}
    &
    \text{(R-IApp)}
    \\\\
    \text{(R-Decl)}
    &
    \displaystyle
    \frac{\mathcal{E}, \ o : \cdot \vdash p \downarrow v}
         {\mathcal{E} \vdash \textbf{decl} \ o \ \textbf{in} \ p \downarrow v}
    &
    \displaystyle
    \frac{\mathcal{E}(o) \uplus (e, \ \sigma_T) \vdash p \downarrow v}
         {\mathcal{E} \vdash \textbf{inst} \ o : \sigma_T = \ e \ \textbf{in} \ p \downarrow v}
    &
    \text{(R-Inst)}
    \\\\
    \text{(R-CApp)}
    &
    \displaystyle
    \frac{\mathcal{E} \vdash e_1 \downarrow v_1 \ .. \ \mathcal{E} \vdash e_1 \downarrow v_1}
         {\mathcal{E} \vdash k \ e_1 \ .. \ e_n \downarrow k \ v_1 \ .. \ v_n}
    &
    \displaystyle
    \frac{\mathcal{E} \vdash e^\prime \downarrow v^\prime \quad\quad \mathcal{E},\ x : v^\prime \vdash e \downarrow v}
         {\mathcal{E} \vdash \textbf{let} \ x = e^\prime \ \textbf{in} \ e \downarrow v}
    &
    \text{(R-Let)}
  \end{array}$$
  \\\\
  where $v \sqsubseteq T:$
  $$\begin{array}{c c c c c c} 
    \text{(C-Abs)}
    &
    \displaystyle
    \frac{}
         {\lambda (\mathcal{E}; \ x). \ e \sqsubseteq \ \rightarrow}
    &
    \text{(C-Cstr)}
    &
    \displaystyle
    \frac{k \in \mathcal{K}_D}
    {k \ v_1 \ .. \ v_n \sqsubseteq D}
    &
    \text{(C-Inst)}
    &
    \displaystyle
    \frac{}
    {S \sqsubseteq \ \rightarrow}
  \end{array}$$
  \caption{Big Step Semantics ($\mathcal{E} \vdash p \downarrow v$)}
\end{figure}
\noindent Rules (R-Var), (R-App), (R-Abs), (R-Let) are standard. 

(R-CApp) evaluates $n$-ary predefined constructors, threating $k$ as a function applied to $n$ arguments. 

Analogous to (T-Decl), (R-Decl) adds the overloaded identifier to the evaluation context with zero instances and evaluates the continuation.

When an expression $e_1$, that evaluates to a list of type annotated expressions $S$, is applied to some $e_2$, the (R-IApp) rule is invoked. If there exists an instance $(e^\prime, \ \sigma_T) \in S$ which's type $T$ matches the type of the argument $e_2$, we take $e^\prime$ and apply $e_2$ to it. 

The binary relation $v \sqsubseteq T$ relates constructor values to their corresponding type and is used inside (R-IApp).
\subsection{Debruijn Indices}
In contrast to the original paper our system has the advantage of having only exactly one entry in environments per overloaded identifier. Instead of a new entry for each instance declaration we extend the list of types for each overloaded identifier in $\Gamma$ and list of expressions in $\mathcal{E}$ respectively. The reason for introducing the \snip{decl} expression to the language is to have exactly one specific expression to define the new variable, all instance definitions then refer to this one variable. With these changes transforming a given program to debruijn representation is straight forward.

\section{Conclusion}
We have studied System O, a minimal system that is foundation of many popular programming languages features like type classes and traits. Because of the close relation to Hindley Milner's system, full type inference is preserved by a simple extension of Algorithm W. System O itself is foundation to many more advanced systems and can be extend by a lot of interesting features. Exemplary, we studied the extension of System O by recursive instance declarations.

\begin{thebibliography}{8}

\bibitem{oww95}Odersky, M., Wadler, P. \& Wehr, M. A Second Look at Overloading. {\em Proceedings Of The Seventh International Conference On Functional Programming Languages And Computer Architecture}. pp. 135-146 (1995), https://doi.org/10.1145/224164.224195
\bibitem{hm78}Milner, R. A theory of type polymorphism in programming. {\em Journal Of Computer And System Sciences}. \textbf{17}, 348-375 (1978), https://www.sciencedirect.com/science/article/pii/0022000078900144
\bibitem{dm82}Damas, L. \& Milner, R. Principal Type-Schemes for Functional Programs. {\em Proceedings Of The 9th ACM SIGPLAN-SIGACT Symposium On Principles Of Programming Languages}. pp. 207-212 (1982), https://doi.org/10.1145/582153.582176
\end{thebibliography}
\end{document}
